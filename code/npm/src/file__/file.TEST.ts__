import { expect } from 'chai';
import { expectError } from '@tdb/test';
import { fs, fsPath, yaml } from '../common';
import { file } from '.';

describe('file.loadAndParse', () => {
  it('throws if file-type not supported', async () => {
    expectError(() => file.loadAndParse('./test/sample/file'));
    expectError(() => file.loadAndParse('./test/sample/file.doc'));

    expect(() => file.loadAndParseSync('./test/sample/file')).to.throw();
    expect(() => file.loadAndParseSync('./test/sample/file.doc')).to.throw();
  });

  it('throws if file cannot be parsed', async () => {
    expectError(() => file.loadAndParse('./test/sample/fail.json'));
    expectError(() => file.loadAndParse('./test/sample/fail.yml'));

    expect(() => file.loadAndParseSync('./test/sample/fail.json')).to.throw();
    expect(() => file.loadAndParseSync('./test/sample/fail.yml')).to.throw();
  });

  it('return nothing when file not found', async () => {
    expect(file.loadAndParseSync('/NO_EXIST')).to.eql(undefined);
    expect(await file.loadAndParse('/NO_EXIST')).to.eql(undefined);
  });

  it('return nothing when directory is passed (requires a file)', async () => {
    expect(file.loadAndParseSync('./test/sample')).to.eql(undefined);
    expect(await file.loadAndParse('./test/sample')).to.eql(undefined);
  });

  it('returns a default value', async () => {
    const DEFAULT = { foo: 123 };
    expect(file.loadAndParseSync('/NO_EXIST', DEFAULT)).to.eql(DEFAULT);
    expect(await file.loadAndParse('/NO_EXIST', DEFAULT)).to.eql(DEFAULT);
  });

  it('loads and parses JSON', async () => {
    type MyType = { name: string };
    const path = './test/sample/foo.json';
    const res1 = await file.loadAndParse<MyType>(path);
    const res2 = file.loadAndParseSync<MyType>(path);
    expect(res1 && res1.name).to.eql('Bob');
    expect(res2 && res2.name).to.eql('Bob');
  });

  it('loads and parses [yml]', async () => {
    type MyType = { foo: { ext: string } };
    const path = './test/sample/foo.yml';
    const res1 = await file.loadAndParse<MyType>(path);
    const res2 = file.loadAndParseSync<MyType>(path);
    expect(res1 && res1.foo.ext).to.eql('yml');
    expect(res2 && res2.foo.ext).to.eql('yml');
  });

  it('loads and parses [yaml]', async () => {
    type MyType = { foo: { ext: string } };
    const path = './test/sample/foo.yaml';
    const res1 = await file.loadAndParse<MyType>(path);
    const res2 = file.loadAndParseSync<MyType>(path);
    expect(res1 && res1.foo.ext).to.eql('yaml');
    expect(res2 && res2.foo.ext).to.eql('yaml');
  });
});

describe('file.stringifyAndSave', () => {
  const TMP = fsPath.resolve('./tmp');
  afterEach(async () => fs.remove(TMP));

  const readTmp = (name: string) => {
    const path = fsPath.resolve(fsPath.join('./tmp', name));
    return fs.readFileSync(path, 'utf8');
  };

  it('throws if file-type not supported', async () => {
    const obj = { foo: 123 };
    expectError(() => file.stringifyAndSave('./tmp/file', obj));
    expectError(() => file.stringifyAndSave('./tmp/file.doc', obj));

    expect(() => file.stringifyAndSaveSync('./tmp/file', obj)).to.throw();
    expect(() => file.stringifyAndSaveSync('./tmp/file.doc', obj)).to.throw();
  });

  it('saves [yml, yaml]', async () => {
    const obj = { name: 'Mary', list: [1, 2, 3] };
    const text = yaml.dump(obj);

    const res1 = await file.stringifyAndSave('./tmp/file-1.yml', obj);
    const res2 = file.stringifyAndSaveSync('./tmp/file-2.yaml', obj);
    const res3 = await file.stringifyAndSave('./tmp/file-3.yml', obj);
    const res4 = file.stringifyAndSaveSync('./tmp/file-4.yaml', obj);

    expect(res1).to.eql(text);
    expect(res2).to.eql(text);
    expect(res3).to.eql(text);
    expect(res4).to.eql(text);

    const file1 = readTmp('file-1.yml');
    const file2 = readTmp('file-2.yaml');
    const file3 = readTmp('file-3.yml');
    const file4 = readTmp('file-4.yaml');

    expect(file1).to.eql(text);
    expect(file2).to.eql(text);
    expect(file3).to.eql(text);
    expect(file4).to.eql(text);
  });

  it('saves [json]', async () => {
    const obj = { name: 'Mary', list: [1, 2, 3] };
    const text = `${JSON.stringify(obj, null, '  ')}\n`;

    const res1 = await file.stringifyAndSave('./tmp/file-1.json', obj);
    const res2 = file.stringifyAndSaveSync('./tmp/file-2.json', obj);

    expect(res1).to.eql(text);
    expect(res2).to.eql(text);

    const file1 = readTmp('file-1.json');
    const file2 = readTmp('file-2.json');

    expect(file1).to.eql(text);
    expect(file2).to.eql(text);
  });

  it('calls BEFORE handler (async)', async () => {
    const obj = { foo: 123 };
    const res = await file.stringifyAndSave('./tmp/file-1.json', obj, {
      beforeSave: async e => {
        const filename = fsPath.basename(e.path);
        return `// Inserted comment for file '${filename}' \n${e.text}`;
      },
    });
    const file1 = readTmp('file-1.json');
    expect(res).to.include(`// Inserted comment for file 'file-1.json'`);
    expect(file1).to.include(`// Inserted comment for file 'file-1.json'`);
  });

  it('calls BEFORE handler (async)', () => {
    const obj = { foo: 123 };
    const res = file.stringifyAndSaveSync('./tmp/file-1.json', obj, {
      beforeSave: e => {
        const filename = fsPath.basename(e.path);
        return `// Inserted comment for file '${filename}' \n${e.text}`;
      },
    });
    const file1 = readTmp('file-1.json');
    expect(res).to.include(`// Inserted comment for file 'file-1.json'`);
    expect(file1).to.include(`// Inserted comment for file 'file-1.json'`);
  });
});
