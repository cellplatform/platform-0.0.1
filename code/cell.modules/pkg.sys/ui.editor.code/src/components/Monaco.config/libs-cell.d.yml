libs:
  index.d.ts: ''
  types.cli.d.ts: |-
    declare type O = Record<string, unknown>;
    export declare type CellCli = O;
    export {};
  types.db.d.ts: >-
    import { IModel, IModelLinksSchema, IModelChildrenSchema } from
    '@platform/fsdb.types';

    declare type O = Record<string, unknown>;

    export declare type IDbModelChange = {
        uri: string;
        field: string;
        from?: any;
        to?: any;
    };

    export declare type IDbModelNs<P extends O = any> =
    IModel<IDbModelNsProps<P>, IDbModelNsDoc<P>, IDbModelNsLinks,
    IDbModelNsChildren>;

    export declare type IDbModelNsProps<P extends O = any> = INs & P;

    export declare type IDbModelNsDoc<P extends O = any> = IDbModelNsProps<P>;

    export declare type IDbModelNsLinks = IModelLinksSchema;

    export declare type IDbModelNsChildren = {
        cells: IDbModelCell[];
        columns: IDbModelColumn[];
        rows: IDbModelRow[];
        files: IDbModelFile[];
    };

    export declare type IDbModelCell<P extends O = any> =
    IModel<IDbModelCellProps<P>, IDbModelCellDoc<P>, IDbModelCellLinks,
    IDbModelCellChilden>;

    export declare type IDbModelCellProps<P extends O = any> =
    ICellData<IDbModelCellDataProps<P>>;

    export declare type IDbModelCellDataProps<P extends O = any> = ICellProps &
    P;

    export declare type IDbModelCellDoc<P extends O = any> =
    IDbModelCellProps<P> & {
        nsRefs?: string[];
    };

    export declare type IDbModelCellLinks = {
        namespaces: IDbModelNs[];
    };

    export declare type IDbModelCellChilden = IModelChildrenSchema;

    export declare type IDbModelRow<P extends O = any> =
    IModel<IDbModelRowProps<P>, IDbModelRowDoc<P>, IDbModelRowLinks,
    IDbModelRowChildren>;

    export declare type IDbModelRowProps<P extends O = any> =
    IRowData<IDbModelRowDataProps<P>>;

    export declare type IDbModelRowDataProps<P extends O = any> = IRowProps & P;

    export declare type IDbModelRowDoc<P extends O = any> = IDbModelRowProps<P>;

    export declare type IDbModelRowLinks = IModelLinksSchema;

    export declare type IDbModelRowChildren = IModelChildrenSchema;

    export declare type IDbModelColumn<P extends O = any> =
    IModel<IDbModelColumnProps<P>, IDbModelColumnDoc<P>, IDbModelColumnLinks,
    IDbModelColumnChildren>;

    export declare type IDbModelColumnProps<P extends O = any> =
    IColumnData<IDbModelColumnDataProps<P>>;

    export declare type IDbModelColumnDataProps<P extends O = any> =
    IColumnProps & P;

    export declare type IDbModelColumnDoc<P extends O = any> =
    IDbModelColumnProps<P>;

    export declare type IDbModelColumnLinks = IModelLinksSchema;

    export declare type IDbModelColumnChildren = IModelChildrenSchema;

    export declare type IDbModelFile = IModel<IDbModelFileProps,
    IDbModelFileDataProps, IDbModelFileLinks, IDbModelFileChildren>;

    export declare type IDbModelFileProps = IFileData;

    export declare type IDbModelFileDataProps = IDbModelFileProps;

    export declare type IDbModelFileLinks = IModelLinksSchema;

    export declare type IDbModelFileChildren = IModelChildrenSchema;

    export {};
  types.func.d.ts: >-
    export declare type FuncParam = Json | undefined;

    export declare type FuncResponse = any;

    export declare type FuncInvoker = (args: {
        params: FuncParam[];
    }) => Promise<FuncResponse>;

    export declare type GetFunc = (args: IGetFuncArgs) => Promise<FuncInvoker |
    undefined>;

    export declare type IGetFuncArgs = {
        namespace: string;
        name: string;
    };

    export declare type FuncPromise<T> = Promise<T> & {
        eid: string;
    };

    export declare type IFuncResponse<T = any> = {
        ok: boolean;
        eid: string;
        elapsed: number;
        type: RefTarget;
        cell: string;
        formula: string;
        data?: T;
        error?: IFuncError;
    };

    export declare type IFuncResponseMap = {
        [key: string]: IFuncResponse;
    };

    export declare type IFuncManyResponse = {
        ok: boolean;
        eid: string;
        elapsed: number;
        list: IFuncResponse[];
        map: IFuncResponseMap;
    };

    export declare type IFuncTable = {
        cache: IMemoryCache;
        getCells: GetCells;
        refsTable: IRefsTable;
        getFunc: GetFunc;
        calculate(args?: {
            cells?: string | string[];
            event$?: Subject<FuncEvent>;
        }): FuncPromise<IFuncTableResponse>;
    };

    export declare type IFuncTableResponse = {
        ok: boolean;
        eid: string;
        elapsed: number;
        list: IFuncResponse[];
        map: ICellMap;
    };

    export declare type FuncEvent = FuncOneEvent | FuncManyEvent;

    export declare type FuncOneEvent = IFuncBeginEvent | IFuncEndEvent;

    export declare type FuncManyEvent = IFuncManyBeginEvent | IFuncManyEndEvent;

    export declare type IFuncBeginEvent = {
        type: 'FUNC/begin';
        payload: IFuncBegin;
    };

    export declare type IFuncBegin = {
        eid: string;
        cell: string;
        formula: string;
    };

    export declare type IFuncEndEvent = {
        type: 'FUNC/end';
        payload: IFuncEnd;
    };

    export declare type IFuncEnd = IFuncResponse;

    export declare type IFuncManyBeginEvent = {
        type: 'FUNC/many/begin';
        payload: IFuncManyBegin;
    };

    export declare type IFuncManyBegin = {
        eid: string;
        cells: string[];
    };

    export declare type IFuncManyEndEvent = {
        type: 'FUNC/many/end';
        payload: IFuncManyEnd;
    };

    export declare type IFuncManyEnd = IFuncManyResponse;
  types.func.sys.d.ts: |-
    declare type O = Record<string, unknown>;
    export declare type IFuncSys = O;
    export {};
  types.links.d.ts: >-
    export declare type ILinkKey = {
        prefix: string;
        key: string;
        path: string;
        dir: string;
        name: string;
        ext: string;
    };

    export declare type ILinkValue<U extends IUri, Q extends ILinkQuery> = {
        uri: U;
        value: string;
        query: Q;
    };

    export declare type ILink<U extends IUri, Q extends ILinkQuery> = ILinkKey &
    ILinkValue<U, Q>;

    export declare type ILinkQuery = Record<string, string | boolean>;

    export declare type IFileLink = ILink<IFileUri, IFileLinkQuery> & {
        toString: FileLinkToString;
    };

    export declare type IFileLinkQuery = ILinkQuery & {
        hash?: string;
        status?: FileLinkQueryStatus;
    };

    export declare type FileLinkQueryStatus = 'uploading';

    export declare type FileLinkToString = (options?: {
        hash?: string | null;
        status?: string | null;
    }) => string;

    export declare type IRefLink<U extends IRefLinkUri = IRefLinkUri> = ILink<U,
    IRefLinkQuery> & {
        toString: RefLinkToString;
    };

    export declare type IRefLinkUri = INsUri | ICellUri | IColumnUri | IRowUri;

    export declare type IRefLinkQuery = ILinkQuery & {
        hash?: string;
    };

    export declare type RefLinkToString = (options?: {
        hash?: string | null;
    }) => string;
