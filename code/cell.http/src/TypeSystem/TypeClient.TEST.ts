import { TypeSystem } from '../TypeSystem';
import { testFetch } from '../TypeSystem/test';
import { expect, fs, TYPE_DEFS } from './test';

describe.only('TypeClient', () => {
  const fetch = testFetch({ defs: TYPE_DEFS });

  describe('load', () => {
    it('"ns:foo"', async () => {
      const type = await TypeSystem.Type.load({ ns: 'ns:foo', fetch });
      expect(type.uri).to.eql('ns:foo');
      expect(type.ok).to.eql(true);
    });

    it('"foo" (without "ns:" prefix)', async () => {
      const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
      expect(type.uri).to.eql('ns:foo');
      expect(type.ok).to.eql(true);
    });
  });

  describe.only('errors', () => {
    it('throw: malformed URI', async () => {
      const type = await TypeSystem.Type.load({ ns: 'ns:not-valid', fetch });
      expect(type.ok).to.eql(false);
      expect(type.errors[0].message).to.include(`invalid "ns" identifier`);
    });

    it('throw: not a "ns" uri', async () => {
      const type = await TypeSystem.Type.load({ ns: 'cell:foo!A1', fetch });
      expect(type.ok).to.eql(false);
      expect(type.errors[0].message).to.include(`Must be "ns"`);
    });

    it.skip('throw: ref not found (404)', async () => {
      //
    });
  });

  it.skip('load (type does not exist)', () => {}); // tslint:disable-line

  it.skip('n-level deep type refs', () => {}); // tslint:disable-line
  it.skip('circular-reference safe (on recursive type lookup)', () => {}); // tslint:disable-line
  it.skip('primitive types (string, bool, number, null, object)', () => {}); // tslint:disable-line

  describe('typescript', () => {
    it('all types with header (default)', async () => {
      const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
      const res = type.typescript();

      expect(res).to.include('Generated by');
      expect(res).to.include('export declare type MyRow');
      expect(res).to.include('export declare type MyColor');
    });

    it('no header', async () => {
      const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
      const res = type.typescript({ header: false });

      expect(res).to.not.include('Generated by');
      expect(res).to.include('export declare type MyRow');
      expect(res).to.include('export declare type MyColor');
    });
  });

  describe('typescript: save file (.d.ts)', () => {
    const fetch = testFetch({ defs: TYPE_DEFS });

    it('save for local tests', async () => {
      const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
      await type.save(fs).typescript(fs.join(__dirname, '.d.ts'));
    });

    it('dir (filename inferred from type)', async () => {
      const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
      const typescript = type.typescript();
      const dir = fs.resolve('tmp/d');
      const res = await type.save(fs).typescript(dir);

      expect(res.path.endsWith('/d/MyRow.d.ts')).to.eql(true);
      expect(res.data).to.eql(typescript);

      const file = await fs.readFile(fs.join(dir, 'MyRow.d.ts'));
      expect(file.toString()).to.eql(typescript);
    });

    it('filename (explicit)', async () => {
      const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
      const typescript = type.typescript();
      const dir = fs.resolve('tmp/d');
      const res1 = await type.save(fs).typescript(dir, { filename: 'Foo.txt' }); // NB: ".d.ts" automatically added.
      const res2 = await type.save(fs).typescript(dir, { filename: 'Foo.d.ts' });

      expect(res1.path.endsWith('/d/Foo.txt.d.ts')).to.eql(true);
      expect(res2.path.endsWith('/d/Foo.d.ts')).to.eql(true);

      const file1 = await fs.readFile(fs.join(dir, 'Foo.txt.d.ts'));
      const file2 = await fs.readFile(fs.join(dir, 'Foo.d.ts'));

      expect(file1.toString()).to.eql(typescript);
      expect(file2.toString()).to.eql(typescript);
    });
  });
});
