import * as g from './.d.ts/MyRow';

import { fs, t, expect, http, createMock, stripHashes, post, Schema, HttpClient } from '../test';
import { testFetch, testInstanceFetch } from '../TypeSystem/test';
import { TypeSystem } from '../TypeSystem';

/**
 * TODO 游냥TESTS
 * - ref: not NS URI
 * - ref: not found (404)
 * - n-level deep type refs.
 * - circular ref safe on referenced type
 * - different types
 */

/**
 * TODO 游냥 Features
 * - different scalar types
 * - handle enums (?)
 * - error check typename on NS upon writing (Captialised, no spaces)
 * - ns (read): query on subset of rows (index/take)
 * - ns (read): query string {ns:false} - omit ns data.
 * - change handler (pending => save)
 * - read/write: linked sheet
 */

type SampleTypeDefs = { 'ns:foo': t.ITypeDefPayload; 'ns:foo.color': t.ITypeDefPayload };

const TYPE_DEFS: SampleTypeDefs = {
  'ns:foo': {
    ns: {
      type: { typename: 'MyRow' },
    },
    columns: {
      A: { props: { prop: { name: 'title', type: 'string' } } },
      B: { props: { prop: { name: 'isEnabled', type: 'boolean', target: 'inline:isEnabled' } } },
      C: {
        props: { prop: { name: 'color', type: '=ns:foo.color', target: 'inline:color' } },
      },
      // TEMP 游냥 list / inline
      // C: { props: { prop: { name: 'colors', type: '=ns:foo.color[]', inline: true } } }, // TODO 游냥 list([array]) / inline
    },
  },

  'ns:foo.color': {
    ns: {
      type: { typename: 'MyColor' },
    },
    columns: {
      A: { props: { prop: { name: 'label', type: 'string' } } },
      B: { props: { prop: { name: 'color', type: '"red" | "green" | "blue"' } } },
    },
  },
};

describe.only('TypeSystem (isolated stub data)', () => {
  describe('TypeClient', () => {
    it.skip('load "ns:foo"', () => {}); // tslint:disable-line
    it.skip('load "foo" (no "ns:" prefix)', () => {}); // tslint:disable-line
    it.skip('load (malformed URI)', () => {}); // tslint:disable-line
    it.skip('load (type does not exist)', () => {}); // tslint:disable-line

    it.skip('throw: not a "ns" uri', () => {}); // tslint:disable-line
    it.skip('throw: ref not found (404)', () => {}); // tslint:disable-line
    it.skip('n-level deep type refs', () => {}); // tslint:disable-line
    it.skip('circular-reference safe (on recursive type lookup)', () => {}); // tslint:disable-line
    it.skip('primitive types (string, bool, number, null, object)', () => {}); // tslint:disable-line

    describe('typescript', () => {
      const fetch = testFetch({ defs: TYPE_DEFS });

      it('all types with header (default)', async () => {
        const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
        const res = type.typescript();

        expect(res).to.include('Generated by');
        expect(res).to.include('export declare type MyRow');
        expect(res).to.include('export declare type MyColor');
      });

      it('no header', async () => {
        const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
        const res = type.typescript({ header: false });

        expect(res).to.not.include('Generated by');
        expect(res).to.include('export declare type MyRow');
        expect(res).to.include('export declare type MyColor');
      });
    });

    describe('save: typescript defs as file (.d.ts)', () => {
      const fetch = testFetch({ defs: TYPE_DEFS });

      it('save for tests', async () => {
        const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
        await type.save(fs).typescript(fs.join(__dirname, '.d.ts'));
      });

      it('dir (filename inferred from type)', async () => {
        const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
        const typescript = type.typescript();
        const dir = fs.resolve('tmp/d');
        const res = await type.save(fs).typescript(dir);

        expect(res.path.endsWith('/d/MyRow.d.ts')).to.eql(true);
        expect(res.data).to.eql(typescript);

        const file = await fs.readFile(fs.join(dir, 'MyRow.d.ts'));
        expect(file.toString()).to.eql(typescript);
      });

      it('filename (explicit)', async () => {
        const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
        const typescript = type.typescript();
        const dir = fs.resolve('tmp/d');
        const res1 = await type.save(fs).typescript(dir, { filename: 'Foo.txt' }); // NB: ".d.ts" automatically added.
        const res2 = await type.save(fs).typescript(dir, { filename: 'Foo.d.ts' });

        expect(res1.path.endsWith('/d/Foo.txt.d.ts')).to.eql(true);
        expect(res2.path.endsWith('/d/Foo.d.ts')).to.eql(true);

        const file1 = await fs.readFile(fs.join(dir, 'Foo.txt.d.ts'));
        const file2 = await fs.readFile(fs.join(dir, 'Foo.d.ts'));

        expect(file1.toString()).to.eql(typescript);
        expect(file2.toString()).to.eql(typescript);
      });
    });
  });

  describe('TypedSheet', () => {
    it.skip('read/write primitive types', () => {}); // tslint:disable-line
    it.skip('read/write ref (singular) - linked sheet', () => {}); // tslint:disable-line
    it.skip('read/write ref (array/list) - linked sheet', () => {}); // tslint:disable-line
    it.skip('query (paging: index/skip)', () => {}); // tslint:disable-line
    it.skip('events$ - observable (change/pending-save alerts)', () => {}); // tslint:disable-line
    it.skip('write to non-existent row (new row auto-generated)', () => {}); // tslint:disable-line
    it.skip('', () => {}); // tslint:disable-line

    describe('cursor', () => {
      it('inline: read (strongly typed prop)', async () => {
        const ns = 'ns:foo.mySheet';
        const fetch = await testInstanceFetch({
          ns,
          implements: 'ns:foo',
          defs: TYPE_DEFS,
          rows: [
            { title: 'One', isEnabled: true, color: { label: 'background', color: 'red' } },
            { title: 'Two', isEnabled: false, color: { label: 'foreground', color: 'blue' } },
          ],
        });

        const sheet = await TypeSystem.Sheet.load<g.MyRow>({ fetch, ns });
        const cursor = await sheet.cursor();

        const row1 = cursor.row(0);
        const row2 = cursor.row(1);
        const row3 = cursor.row(2);

        expect(row1).to.not.eql(undefined);
        expect(row2).to.not.eql(undefined);
        expect(row3).to.eql(undefined);

        if (row1) {
          expect(row1.title).to.eql('One');
          expect(row1.isEnabled).to.eql(true);
          expect(row1.color).to.eql({ label: 'background', color: 'red' });
        }

        if (row2) {
          expect(row2.title).to.eql('Two');
          expect(row2.isEnabled).to.eql(false);
          expect(row2.color).to.eql({ label: 'foreground', color: 'blue' });
        }
      });

      it('inline: write (strongly typed prop)', async () => {
        const ns = 'ns:foo.mySheet';
        const fetch = await testInstanceFetch({
          ns,
          implements: 'ns:foo',
          defs: TYPE_DEFS,
          rows: [],
        });

        const sheet = await TypeSystem.Sheet.load<g.MyRow>({ fetch, ns });
        const cursor = await sheet.cursor();
      });
    });
  });
});
