import * as g from './.d.ts/MyRow';

import { fs, t, expect, http, createMock, stripHashes, post, Schema, HttpClient } from '../test';
import { testFetch, testInstanceFetch } from '../TypeSystem/test';
import { TypeSystem } from '../TypeSystem';

/**
 * TODO 游냥TESTS
 * - ref: not NS URI
 * - ref: not found (404)
 * - n-level deep type refs.
 * - circular ref safe on referenced type
 * - different types
 */

/**
 * TODO 游냥 Features
 * - different scalar types
 * - handle enums (?)
 * - error check typename on NS upon writing (Captialised, no spaces)
 * - ns (read): query on subset of rows (index/take)
 * - ns (read): query string {ns:false} - omit ns data.
 * - change handler (pending => save)
 * - read/write: linked sheet
 */

type SampleTypeDefs = { 'ns:foo': t.ITypeDefPayload; 'ns:foo.color': t.ITypeDefPayload };

const TYPE_DEFS: SampleTypeDefs = {
  'ns:foo': {
    ns: {
      type: { typename: 'MyRow' },
    },
    columns: {
      A: { props: { prop: { name: 'title', type: 'string' } } },
      B: { props: { prop: { name: 'isEnabled', type: 'boolean', target: 'inline:isEnabled' } } },
      C: {
        props: { prop: { name: 'color', type: '=ns:foo.color', target: 'inline:color' } },
      },
      // TEMP 游냥 list / inline
      // C: { props: { prop: { name: 'colors', type: '=ns:foo.color[]', inline: true } } }, // TODO 游냥 list([array]) / inline
    },
  },

  'ns:foo.color': {
    ns: {
      type: { typename: 'MyColor' },
    },
    columns: {
      A: { props: { prop: { name: 'label', type: 'string' } } },
      B: { props: { prop: { name: 'color', type: '"red" | "green" | "blue"' } } },
    },
  },
};

// const testFetch = (data: { defs: { [ns: string]: t.ITypeDefPayload }; cells?: t.ICellMap }) => {
//   const getType: t.FetchSheetType = async args => {
//     const ns = data.defs[args.ns]?.ns;
//     const type = ns?.type as t.INsType;
//     const exists = Boolean(type);
//     return { exists, type };
//   };

//   const getColumns: t.FetchSheetColumns = async args => {
//     const def = data.defs[args.ns];
//     const columns = def?.columns || {};
//     return { columns };
//   };

//   const getCells: t.FetchSheetCells = async args => {
//     const cells = data.cells || {};
//     const rows = Schema.coord.cell.max.row(Object.keys(cells));
//     const total = { rows };
//     return { cells, total };
//   };

//   return TypeSystem.fetcher.fromFuncs({ getType, getColumns, getCells });
// };

// const testInstanceFetch = async <T>(args: {
//   ns: string;
//   implements: string;
//   defs: { [ns: string]: t.ITypeDefPayload };
//   rows: T[];
// }) => {
//   const typeClient = await TypeSystem.Type.load({
//     ns: args.implements,
//     fetch: testFetch({ defs: args.defs }),
//   });
//   const cells = TypeSystem.objectToCells<T>(typeClient).rows(0, args.rows);
//   const def: t.ITypeDefPayload = {
//     ns: { type: { implements: args.implements } },
//     columns: {},
//   };
//   return testFetch({
//     cells,
//     defs: { ...args.defs, [args.ns]: def },
//   });
// };

const writeTypes = async (args: { client: t.IHttpClient }) => {
  const { client } = args;

  await client.ns('foo').write(TYPE_DEFS['ns:foo']);
  await client.ns('foo.color').write(TYPE_DEFS['ns:foo.color']);

  return { client };
};

describe('TypeSystem', () => {
  it('sample (http)', async () => {
    //
    const mock = await createMock();
    const client = mock.client;

    await writeTypes({ client });

    // const res2 = await mock.client.ns('foo').read({ data: true });

    console.log('-------------------------------------------');
    const url = mock.url('ns:foo/types');
    const res3 = await http.get(url);
    const json = res3.json as t.IResGetNsTypes;

    console.log('json.types', json.types);
    console.log('-------------------------------------------');
    console.log('json.types[2]', json.types[2].type);

    console.log('-------------------------------------------');
    // console.log('status', res3.status);
    // console.log(res3.json?.types);
    // console.log('Schema.uri.allow', Schema.uri.ALLOW);

    console.log('-------------------------------------------');
    console.log('');
    console.log(json.typescript);

    await mock.dispose();
  });

  it.skip('load "ns:foo"', () => {}); // tslint:disable-line
  it.skip('load "foo" (no "ns:" prefix)', () => {}); // tslint:disable-line
  it.skip('load (malformed URI)', () => {}); // tslint:disable-line
  it.skip('load (type does not exist)', () => {}); // tslint:disable-line

  describe('typescript', () => {
    const fetch = testFetch({ defs: TYPE_DEFS });

    it('all types with header (default)', async () => {
      const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
      const res = type.typescript();

      expect(res).to.include('Generated by');
      expect(res).to.include('export declare type MyRow');
      expect(res).to.include('export declare type MyColor');
    });

    it('no header', async () => {
      const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
      const res = type.typescript({ header: false });

      expect(res).to.not.include('Generated by');
      expect(res).to.include('export declare type MyRow');
      expect(res).to.include('export declare type MyColor');
    });
  });

  describe('save: typescript defs as file (.d.ts)', () => {
    const fetch = testFetch({ defs: TYPE_DEFS });

    it('save for tests', async () => {
      const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
      await type.save(fs).typescript(fs.join(__dirname, '.d.ts'));
    });

    it('dir (filename inferred from type)', async () => {
      const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
      const typescript = type.typescript();
      const dir = fs.resolve('tmp/d');
      const res = await type.save(fs).typescript(dir);

      expect(res.path.endsWith('/d/MyRow.d.ts')).to.eql(true);
      expect(res.data).to.eql(typescript);

      const file = await fs.readFile(fs.join(dir, 'MyRow.d.ts'));
      expect(file.toString()).to.eql(typescript);
    });

    it('filename (explicit)', async () => {
      const type = await TypeSystem.Type.load({ ns: 'foo', fetch });
      const typescript = type.typescript();
      const dir = fs.resolve('tmp/d');
      const res1 = await type.save(fs).typescript(dir, { filename: 'Foo.txt' }); // NB: ".d.ts" automatically added.
      const res2 = await type.save(fs).typescript(dir, { filename: 'Foo.d.ts' });

      expect(res1.path.endsWith('/d/Foo.txt.d.ts')).to.eql(true);
      expect(res2.path.endsWith('/d/Foo.d.ts')).to.eql(true);

      const file1 = await fs.readFile(fs.join(dir, 'Foo.txt.d.ts'));
      const file2 = await fs.readFile(fs.join(dir, 'Foo.d.ts'));

      expect(file1.toString()).to.eql(typescript);
      expect(file2.toString()).to.eql(typescript);
    });
  });
});

describe('TypedSheet', () => {
  it('read from http (server)', async () => {
    const mock = await createMock();
    const client = mock.client;
    await writeTypes({ client });

    const types = await TypeSystem.Type.client(client).load('ns:foo');
    const cells = TypeSystem.objectToCells<g.MyRow>(types).rows(0, [
      { title: 'One', isEnabled: true, color: { label: 'background', color: 'red' } },
      { title: 'Two', isEnabled: false, color: { label: 'foreground', color: 'blue' } },
    ]);

    await client.ns('foo.mySheet').write({
      ns: { type: { implements: 'ns:foo' } },
      cells,
    });

    const sheet = await TypeSystem.Sheet.client(client).load<g.MyRow>('ns:foo.mySheet');
    const cursor = await sheet.cursor({ index: -5 }); // NB: min-index is 0.
    await mock.dispose();

    expect(cursor.index).to.eql(0);

    const row1 = cursor.row(0);
    const row2 = cursor.row(1);

    expect(row1).to.not.eql(undefined);
    expect(row2).to.not.eql(undefined);

    if (row1) {
      expect(row1.title).to.eql('One');
      expect(row1.isEnabled).to.eql(true);
      expect(row1.color).to.eql({ label: 'background', color: 'red' });
    }

    if (row2) {
      expect(row2.title).to.eql('Two');
      expect(row2.isEnabled).to.eql(false);
      expect(row2.color).to.eql({ label: 'foreground', color: 'blue' });
    }
  });

  describe('cursor', () => {
    it('inline: read', async () => {
      const ns = 'ns:foo.mySheet';
      const fetch = await testInstanceFetch({
        ns,
        implements: 'ns:foo',
        defs: TYPE_DEFS,
        rows: [
          { title: 'One', isEnabled: true, color: { label: 'background', color: 'red' } },
          { title: 'Two', isEnabled: false, color: { label: 'foreground', color: 'blue' } },
        ],
      });

      const sheet = await TypeSystem.Sheet.load<g.MyRow>({ fetch, ns });
      const cursor = await sheet.cursor();

      const row1 = cursor.row(0);
      const row2 = cursor.row(1);
      const row3 = cursor.row(2);

      expect(row1).to.not.eql(undefined);
      expect(row2).to.not.eql(undefined);
      expect(row3).to.eql(undefined);

      if (row1) {
        expect(row1.title).to.eql('One');
        expect(row1.isEnabled).to.eql(true);
        expect(row1.color).to.eql({ label: 'background', color: 'red' });
      }

      if (row2) {
        expect(row2.title).to.eql('Two');
        expect(row2.isEnabled).to.eql(false);
        expect(row2.color).to.eql({ label: 'foreground', color: 'blue' });
      }
    });

    it('inline: write', async () => {
      const ns = 'ns:foo.mySheet';
      const fetch = await testInstanceFetch({
        ns,
        implements: 'ns:foo',
        defs: TYPE_DEFS,
        rows: [],
      });

      const sheet = await TypeSystem.Sheet.load<g.MyRow>({ fetch, ns });
      const cursor = await sheet.cursor();
    });
  });
});
